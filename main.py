import os
import discord
from discord.ext import commands
import asyncio
import aiohttp
import random
import urllib.parse

# Bot setup
intents = discord.Intents.all()
bot = commands.Bot(command_prefix='!', intents=intents)

# Large Image URL
LARGE_IMAGE_URL = "https://media.discordapp.net/attachments/856506862107492402/1425324515034009662/image.png?ex=68e72c65&is=68e5dae5&hm=390850b95ebb0c2bc1eacddd8bdaba22eef053c967a638122fe570bdfb18b724&=&format=webp&quality=lossless"

# Music queues
queues = {}

# Enhanced FFmpeg options for stable streaming
ffmpeg_options = {
    'before_options': (
        '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5 '
        '-fflags +genpts -flags low_delay -strict experimental '
        '-avoid_negative_ts make_zero -fflags +nobuffer '
        '-analyzeduration 0 -probesize 32K -bufsize 512k '
        '-use_wallclock_as_timestamps 1'
    ),
    'options': '-vn -c:a libopus -b:a 128k -f opus'
}

# Embed creation function with LARGE IMAGE
def create_embed(title, description, color=0x00ff00, show_large_image=True):
    """Create embed message with LARGE image (not thumbnail)"""
    embed = discord.Embed(
        title=title,
        description=description,
        color=color,
        timestamp=discord.utils.utcnow()
    )
    
    # Use LARGE image instead of small thumbnail
    if show_large_image:
        embed.set_image(url=LARGE_IMAGE_URL)
    
    embed.set_footer(text="Music Bot ‚Ä¢ Made with ‚ù§Ô∏è")
    return embed

# Updated working Invidious instances (December 2024)
async def get_working_invidious_instances():
    """Get list of currently working Invidious instances"""
    return [
        "https://inv.riverside.rocks",
        "https://invidious.private.coffee",
        "https://yt.artemislena.eu",
        "https://invidious.slipfox.xyz",
        "https://invidious.privacydev.net",
        "https://invidious.namazso.eu",
        "https://yewtu.be",
        "https://invidious.projectsegfau.lt",
        "https://iv.melmac.space",
        "https://invidious.nerdvpn.de",
        "https://inv.bp.projectsegfau.lt",
        "https://invidious.no-logs.com",
        "https://invidious.epicsite.xyz",
        "https://invidious.protokolla.fi",
        "https://vid.puffyan.us"
    ]

# Extract video ID from YouTube URL
def extract_video_id(query):
    """Extract video ID from YouTube URL or return the query as search term"""
    query = query.strip()
    
    # If it's a YouTube URL, extract the video ID
    if 'youtube.com/watch?v=' in query:
        return query.split('v=')[1].split('&')[0]
    elif 'youtu.be/' in query:
        return query.split('youtu.be/')[1].split('?')[0]
    elif 'youtube.com/embed/' in query:
        return query.split('embed/')[1].split('?')[0]
    else:
        # It's a search query, return as is
        return None

# Test if an Invidious instance is working
async def test_invidious_instance(instance):
    """Test if an Invidious instance is working"""
    try:
        timeout = aiohttp.ClientTimeout(total=5)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            # Test with a simple API call
            test_url = f"{instance}/api/v1/stats"
            async with session.get(test_url) as resp:
                return resp.status == 200
    except:
        return False

# Get working instances with testing
async def get_tested_instances():
    """Get and test Invidious instances"""
    instances = await get_working_invidious_instances()
    working_instances = []
    
    # Test instances concurrently
    tasks = [test_invidious_instance(instance) for instance in instances]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    for i, instance in enumerate(instances):
        if results[i] is True:
            working_instances.append(instance)
    
    # If no instances are working, return the original list as fallback
    return working_instances if working_instances else instances

# Search for video using Invidious
async def search_invidious_video(query):
    """Search for a video using Invidious API"""
    instances = await get_tested_instances()
    if not instances:
        instances = await get_working_invidious_instances()
    
    random.shuffle(instances)  # Shuffle for load balancing
    
    video_id = extract_video_id(query)
    
    for instance in instances:
        try:
            timeout = aiohttp.ClientTimeout(total=10)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                if video_id:
                    # Direct video access
                    video_url = f"{instance}/api/v1/videos/{video_id}"
                    async with session.get(video_url) as resp:
                        if resp.status == 200:
                            video_data = await resp.json()
                            return {
                                'video_id': video_id,
                                'title': video_data.get('title', 'Unknown Title'),
                                'duration': video_data.get('duration', 0),
                                'instance': instance,
                                'data': video_data
                            }
                else:
                    # Search for video
                    search_query = urllib.parse.quote(query)
                    search_url = f"{instance}/api/v1/search?q={search_query}&type=video"
                    async with session.get(search_url) as resp:
                        if resp.status == 200:
                            search_data = await resp.json()
                            if search_data and len(search_data) > 0:
                                # Find the first actual video (not playlist, channel, etc.)
                                video = None
                                for item in search_data:
                                    if item.get('type') == 'video':
                                        video = item
                                        break
                                if not video and len(search_data) > 0:
                                    video = search_data[0]
                                
                                if video:
                                    return {
                                        'video_id': video['videoId'],
                                        'title': video.get('title', 'Unknown Title'),
                                        'duration': video.get('duration', 0),
                                        'instance': instance,
                                        'data': video
                                    }
        except Exception as e:
            print(f"‚ùå Instance {instance} failed: {str(e)[:100]}...")
            continue
    
    return None

# Get audio URL from video data
async def get_audio_url(video_info):
    """Get audio URL from video information"""
    if not video_info:
        return None
    
    instance = video_info['instance']
    video_id = video_info['video_id']
    
    try:
        timeout = aiohttp.ClientTimeout(total=10)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            video_url = f"{instance}/api/v1/videos/{video_id}"
            async with session.get(video_url) as resp:
                if resp.status == 200:
                    video_data = await resp.json()
                    
                    # Try different methods to get audio URL
                    
                    # Method 1: Look for adaptive formats (best quality)
                    best_audio = None
                    for stream in video_data.get('adaptiveFormats', []):
                        if 'audio' in stream.get('type', '') and stream.get('url'):
                            current_bitrate = stream.get('bitrate', 0)
                            if not best_audio or current_bitrate > best_audio.get('bitrate', 0):
                                best_audio = stream
                    
                    if best_audio:
                        return {
                            'url': best_audio['url'],
                            'title': video_data.get('title', video_info['title']),
                            'duration': video_data.get('duration', video_info['duration']),
                            'webpage_url': f"https://youtube.com/watch?v={video_id}",
                            'instance': instance
                        }
                    
                    # Method 2: Look for format streams
                    for stream in video_data.get('formatStreams', []):
                        if stream.get('url'):
                            return {
                                'url': stream['url'],
                                'title': video_data.get('title', video_info['title']),
                                'duration': video_data.get('duration', video_info['duration']),
                                'webpage_url': f"https://youtube.com/watch?v={video_id}",
                                'instance': instance
                            }
                    
                    # Method 3: Try to construct URL manually
                    manual_url = f"{instance}/latest_version?id={video_id}&itag=251&local=true"
                    return {
                        'url': manual_url,
                        'title': video_data.get('title', video_info['title']),
                        'duration': video_data.get('duration', video_info['duration']),
                        'webpage_url': f"https://youtube.com/watch?v={video_id}",
                        'instance': instance
                    }
                    
    except Exception as e:
        print(f"‚ùå Failed to get audio from {instance}: {e}")
    
    return None

# Main function to get YouTube audio
async def get_youtube_audio(query):
    """Main function to get YouTube audio using Invidious"""
    print(f"üéµ Searching for: {query}")
    
    # Step 1: Search for video
    video_info = await search_invidious_video(query)
    if not video_info:
        raise Exception("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤")
    
    print(f"‚úÖ Found video: {video_info['title']}")
    
    # Step 2: Get audio URL
    audio_info = await get_audio_url(video_info)
    if not audio_info:
        raise Exception("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ï‡∏£‡∏µ‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ô‡∏µ‡πâ")
    
    print(f"‚úÖ Found audio stream from {audio_info['instance']}")
    return audio_info

# Audio source class for Invidious
class InvidiousSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('webpage_url')

    @classmethod
    async def from_query(cls, query, *, loop=None):
        loop = loop or asyncio.get_event_loop()
        
        data = await get_youtube_audio(query)
        
        if not data:
            raise Exception("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏•‡∏á‡πÑ‡∏î‡πâ")
        
        filename = data['url']
        return cls(discord.FFmpegPCMAudio(filename, **ffmpeg_options), data=data)

# Queue management
def check_queue(ctx, guild_id):
    if queues.get(guild_id):
        if len(queues[guild_id]) > 0:
            source = queues[guild_id].pop(0)
            ctx.voice_client.play(source, after=lambda x=None: check_queue(ctx, guild_id))

# Bot events
@bot.event
async def on_ready():
    print(f'‚úÖ {bot.user} has logged in!')
    print(f'‚úÖ Bot is in {len(bot.guilds)} servers')
    print(f'‚úÖ Using Invidious only (no yt-dlp)')
    
    # Test instances on startup
    working_instances = await get_tested_instances()
    print(f'‚úÖ {len(working_instances)} Invidious instances are working')
    
    await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name="!play"))

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        return
    print(f"Error: {error}")

# Bot commands
@bot.command()
async def join(ctx):
    """Join voice channel"""
    if not ctx.author.voice:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô!", 0xff0000)
        await ctx.send(embed=embed)
        return
    
    channel = ctx.author.voice.channel
    if ctx.voice_client is not None:
        await ctx.voice_client.move_to(channel)
    else:
        await channel.connect()
    
    embed = create_embed("üéµ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß", f"‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á **{channel.name}** ‡πÅ‡∏•‡πâ‡∏ß ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏•‡∏á!")
    await ctx.send(embed=embed)

@bot.command()
async def play(ctx, *, query):
    """‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏à‡∏≤‡∏Å YouTube ‡∏ú‡πà‡∏≤‡∏ô Invidious"""
    if not ctx.author.voice:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô!", 0xff0000)
        await ctx.send(embed=embed)
        return
    
    if ctx.voice_client is None:
        await ctx.author.voice.channel.connect()
    
    async with ctx.typing():
        try:
            player = await InvidiousSource.from_query(query, loop=bot.loop)
            
            if player:
                if not ctx.voice_client.is_playing():
                    await asyncio.sleep(0.3)
                    
                    def play_callback(error):
                        if error:
                            print(f"Playback error: {error}")
                        check_queue(ctx, ctx.guild.id)
                    
                    ctx.voice_client.play(player, after=play_callback)
                    
                    embed = create_embed("üéµ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á", 
                                        f"**{player.title}**\n\n‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏ô‡∏∏‡∏Å‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ü‡∏±‡∏á‡πÄ‡∏û‡∏•‡∏á! üé∂")
                    await ctx.send(embed=embed)
                else:
                    guild_id = ctx.guild.id
                    if guild_id not in queues:
                        queues[guild_id] = []
                    queues[guild_id].append(player)
                    
                    embed = create_embed("‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß‡πÅ‡∏•‡πâ‡∏ß", 
                                        f"**{player.title}**\n\n‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß: #{len(queues[guild_id])}")
                    await ctx.send(embed=embed)
                
        except Exception as e:
            error_msg = str(e)
            print(f"‚ùå Error: {error_msg}")
            
            # More specific error messages
            if "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤" in error_msg:
                error_detail = "Invidious instances ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡∏ä‡πà‡∏ß‡∏á‡∏ô‡∏µ‡πâ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏•‡∏¥‡∏á‡∏Å‡πå YouTube ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á"
            elif "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ï‡∏£‡∏µ‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á" in error_msg:
                error_detail = "‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ô‡∏µ‡πâ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö"
            else:
                error_detail = "‡∏≠‡∏≤‡∏à‡πÄ‡∏Å‡∏¥‡∏î‡∏à‡∏≤‡∏Å‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÄ‡∏û‡∏•‡∏á"
            
            embed = create_embed("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", 
                f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÑ‡∏î‡πâ\n\n"
                f"**‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏:** {error_msg}\n"
                f"**‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:** {error_detail}\n\n"
                f"**‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á:**\n"
                f"‚Ä¢ ‡πÉ‡∏ä‡πâ‡∏•‡∏¥‡∏á‡∏Å‡πå YouTube ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤\n"
                f"‚Ä¢ ‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏•‡∏á‡∏≠‡∏∑‡πà‡∏ô\n"
                f"‚Ä¢ ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà", 0xff0000)
            await ctx.send(embed=embed)

@bot.command()
async def status(ctx):
    """‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏≠‡∏ó"""
    instances = await get_tested_instances()
    total_instances = len(await get_working_invidious_instances())
    
    embed = create_embed("üìä ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏≠‡∏ó", 
        f"**‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:** Invidious ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô\n"
        f"**Invidious instances:** {len(instances)}/{total_instances} ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ\n"
        f"**‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå:** {len(bot.guilds)}\n"
        f"**‡∏û‡∏¥‡∏á:** {round(bot.latency * 1000)}ms\n"
        f"**‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á:** {sum(len(q) for q in queues.values())} ‡πÄ‡∏û‡∏•‡∏á", 0x0099ff)
    await ctx.send(embed=embed)

@bot.command()
async def instances(ctx):
    """‡πÅ‡∏™‡∏î‡∏á Invidious instances ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ"""
    instances = await get_tested_instances()
    total_instances = len(await get_working_invidious_instances())
    
    if instances:
        instances_list = "\n".join([f"‚Ä¢ ‚úÖ {instance}" for instance in instances[:8]])
    else:
        instances_list = "‚Ä¢ ‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ instances ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ"
    
    embed = create_embed("üåê Invidious Instances", 
                        f"**‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞:** {len(instances)}/{total_instances} instances ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ\n\n{instances_list}", 
                        0x0099ff)
    await ctx.send(embed=embed)

@bot.command()
async def pause(ctx):
    """‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏û‡∏•‡∏á‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß"""
    if ctx.voice_client and ctx.voice_client.is_playing():
        ctx.voice_client.pause()
        embed = create_embed("‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß", "‡πÄ‡∏û‡∏•‡∏á‡∏ñ‡∏π‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏ä‡πâ `!resume` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠", 0xffa500)
        await ctx.send(embed=embed)
    else:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def resume(ctx):
    """‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏ï‡πà‡∏≠"""
    if ctx.voice_client and ctx.voice_client.is_paused():
        ctx.voice_client.resume()
        embed = create_embed("‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠", "‡πÄ‡∏û‡∏•‡∏á‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß! üé∂", 0x00ff00)
        await ctx.send(embed=embed)
    else:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def stop(ctx):
    """‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏•‡∏∞‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡∏¥‡∏ß"""
    if ctx.voice_client:
        if ctx.voice_client.is_playing():
            ctx.voice_client.stop()
    
    guild_id = ctx.guild.id
    if guild_id in queues:
        queues[guild_id] = []
    
    embed = create_embed("‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏û‡∏•‡∏á", "‡πÄ‡∏û‡∏•‡∏á‡∏ñ‡∏π‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏Ñ‡∏¥‡∏ß‡∏ñ‡∏π‡∏Å‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß", 0xff0000)
    await ctx.send(embed=embed)

@bot.command()
async def skip(ctx):
    """‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
    if ctx.voice_client and ctx.voice_client.is_playing():
        ctx.voice_client.stop()
        embed = create_embed("‚è≠Ô∏è ‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏û‡∏•‡∏á", "‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!", 0x00ff00)
        await ctx.send(embed=embed)
        check_queue(ctx, ctx.guild.id)
    else:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def queue(ctx):
    """‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á"""
    guild_id = ctx.guild.id
    if guild_id in queues and queues[guild_id]:
        queue_list = "\n".join([f"**{i+1}.** {song.title}" for i, song in enumerate(queues[guild_id])])
        if len(queue_list) > 2000:
            queue_list = queue_list[:1997] + "..."
        
        embed = create_embed("üìã ‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á", f"‡∏°‡∏µ {len(queues[guild_id])} ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß:\n\n{queue_list}", 0x0099ff)
        await ctx.send(embed=embed)
    else:
        embed = create_embed("üìã ‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á", "‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def leave(ctx):
    """‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"""
    if ctx.voice_client:
        await ctx.voice_client.disconnect()
        embed = create_embed("üëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á", "‡∏ö‡∏≠‡∏ó‡πÑ‡∏î‡πâ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£! üéµ", 0x00ff00)
        await ctx.send(embed=embed)
        
        guild_id = ctx.guild.id
        if guild_id in queues:
            del queues[guild_id]
    else:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡∏ö‡∏≠‡∏ó‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def ping(ctx):
    """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á"""
    latency = round(bot.latency * 1000)
    embed = create_embed("üèì Pong!", f"‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á: **{latency}ms**\n\n‡∏ö‡∏≠‡∏ó‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥! ‚úÖ", 0x00ff00)
    await ctx.send(embed=embed)

@bot.command()
async def volume(ctx, volume: int):
    """‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á (0-100)"""
    if ctx.voice_client is None:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á", 0xff0000)
        return await ctx.send(embed=embed)
    
    if 0 <= volume <= 100:
        if ctx.voice_client.source:
            ctx.voice_client.source.volume = volume / 100
        embed = create_embed("üîä ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á", f"‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô **{volume}%** ‡πÅ‡∏•‡πâ‡∏ß", 0x00ff00)
        await ctx.send(embed=embed)
    else:
        embed = create_embed("‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0-100", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def nowplaying(ctx):
    """‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà"""
    if ctx.voice_client and ctx.voice_client.is_playing():
        if hasattr(ctx.voice_client.source, 'title'):
            title = ctx.voice_client.source.title
        else:
            title = "Unknown Title"
            
        embed = create_embed("üéµ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà", 
                            f"**{title}**\n\n‡πÉ‡∏ä‡πâ `!queue` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á", 0x00ff00)
        await ctx.send(embed=embed)
    else:
        embed = create_embed("üéµ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà", "‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà", 0xff0000)
        await ctx.send(embed=embed)

@bot.command()
async def help_bot(ctx):
    """‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
    commands_list = """
**üéµ ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏û‡∏•‡∏á:**
`!play [‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á/‡∏•‡∏¥‡∏á‡∏Å‡πå]` - ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏à‡∏≤‡∏Å YouTube
`!pause` - ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏û‡∏•‡∏á‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
`!resume` - ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏ï‡πà‡∏≠
`!stop` - ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡∏¥‡∏ß
`!skip` - ‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
`!queue` - ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á
`!volume [0-100]` - ‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á
`!nowplaying` - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô
`!status` - ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏≠‡∏ó
`!instances` - ‡πÅ‡∏™‡∏î‡∏á Invidious instances

**üîä ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á:**
`!join` - ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
`!leave` - ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á

**‚ÑπÔ∏è ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:**
`!ping` - ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á
`!help_bot` - ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
"""
    embed = create_embed("ü§ñ ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ö‡∏≠‡∏ó", commands_list, 0x0099ff)
    await ctx.send(embed=embed)

# Run bot
if __name__ == "__main__":
    token = os.environ.get('DISCORD_TOKEN')
    if not token:
        print("‚ùå ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ DISCORD_TOKEN ‡πÉ‡∏ô Environment Variables")
        print("üí° ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Railway Dashboard ‚Üí Variables ‚Üí Add DISCORD_TOKEN")
    else:
        print("üéµ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ö‡∏≠‡∏ó‡πÄ‡∏û‡∏•‡∏á Discord ‡∏ö‡∏ô Railway...")
        print("‚úÖ ‡πÉ‡∏ä‡πâ Invidious ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ yt-dlp)")
        bot.run(token)
